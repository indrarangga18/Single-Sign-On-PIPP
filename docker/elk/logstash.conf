input {
  beats {
    port => 5044
  }
  
  file {
    path => "/var/log/laravel/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    tags => ["laravel"]
  }
  
  file {
    path => "/var/log/nginx/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["nginx"]
  }
  
  file {
    path => "/var/log/php-fpm/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    tags => ["php-fpm"]
  }
}

filter {
  # Laravel Log Processing
  if "laravel" in [tags] {
    if [message] =~ /^\[/ {
      grok {
        match => { 
          "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] %{DATA:environment}\.%{DATA:level}: %{GREEDYDATA:log_message}" 
        }
      }
      
      date {
        match => [ "timestamp", "yyyy-MM-dd HH:mm:ss" ]
      }
      
      # Parse JSON context if present
      if [log_message] =~ /\{.*\}$/ {
        grok {
          match => { 
            "log_message" => "(?<message_text>.*?) (?<context>\{.*\})$" 
          }
        }
        
        json {
          source => "context"
          target => "context_data"
        }
      }
      
      # Extract user information
      if [context_data][user_id] {
        mutate {
          add_field => { "user_id" => "%{[context_data][user_id]}" }
        }
      }
      
      # Extract IP address
      if [context_data][ip] {
        mutate {
          add_field => { "client_ip" => "%{[context_data][ip]}" }
        }
      }
      
      # Extract request information
      if [context_data][method] {
        mutate {
          add_field => { "http_method" => "%{[context_data][method]}" }
        }
      }
      
      if [context_data][url] {
        mutate {
          add_field => { "request_url" => "%{[context_data][url]}" }
        }
      }
      
      # Security event classification
      if [level] == "warning" or [level] == "error" {
        if [log_message] =~ /(?i)(unauthorized|forbidden|failed|invalid|suspicious|attack|injection|xss)/ {
          mutate {
            add_tag => ["security_event"]
          }
        }
      }
      
      # Performance event classification
      if [context_data][duration] {
        mutate {
          add_field => { "response_time" => "%{[context_data][duration]}" }
        }
        
        if [context_data][duration] > 2000 {
          mutate {
            add_tag => ["slow_request"]
          }
        }
      }
    }
  }
  
  # Nginx Access Log Processing
  if "nginx" in [tags] and [source] =~ /access/ {
    grok {
      match => { 
        "message" => "%{NGINXACCESS}" 
      }
    }
    
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    }
    
    mutate {
      convert => { "response" => "integer" }
      convert => { "bytes" => "integer" }
      convert => { "responsetime" => "float" }
    }
    
    # Classify response codes
    if [response] >= 400 and [response] < 500 {
      mutate {
        add_tag => ["client_error"]
      }
    }
    
    if [response] >= 500 {
      mutate {
        add_tag => ["server_error"]
      }
    }
    
    # Detect potential attacks
    if [request] =~ /(?i)(select|union|insert|delete|drop|script|alert|eval)/ {
      mutate {
        add_tag => ["potential_attack"]
      }
    }
  }
  
  # Nginx Error Log Processing
  if "nginx" in [tags] and [source] =~ /error/ {
    grok {
      match => { 
        "message" => "(?<timestamp>%{YEAR}[./-]%{MONTHNUM}[./-]%{MONTHDAY}[- ]%{TIME}) \[%{LOGLEVEL:level}\] %{POSINT:pid}#%{NUMBER:tid}: (\*%{NUMBER:connection_id} )?%{GREEDYDATA:log_message}" 
      }
    }
    
    date {
      match => [ "timestamp", "yyyy/MM/dd HH:mm:ss" ]
    }
  }
  
  # PHP-FPM Log Processing
  if "php-fpm" in [tags] {
    grok {
      match => { 
        "message" => "\[%{HTTPDATE:timestamp}\] %{WORD:level}: %{GREEDYDATA:log_message}" 
      }
    }
    
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    }
  }
  
  # Add common fields
  mutate {
    add_field => { "[@metadata][index_prefix]" => "sso-pipp" }
  }
  
  # GeoIP enrichment for client IPs
  if [client_ip] and [client_ip] !~ /^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.)/ {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
    template_name => "sso-pipp"
    template_pattern => "sso-pipp-*"
    template => "/usr/share/logstash/templates/sso-pipp-template.json"
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}